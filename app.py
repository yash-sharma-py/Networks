from flask import Flask, jsonify, request

app = Flask(__name__)

# Data to be stored and retrieved
data = {
    "c1": """import java.util.Scanner;\n\nclass ShortestPath {\n    int[][] graph; // Declare graph at the class level\n    int V; // Number of vertices\n\n    int minDistance(int dist[], boolean sptSet[]) {\n        int min = Integer.MAX_VALUE, minIndex = -1;\n        for (int v = 0; v < dist.length; v++) {\n            if (!sptSet[v] && dist[v] < min) {\n                min = dist[v];\n                minIndex = v;\n            }\n        }\n        return minIndex;\n    }\n\n    void printSolution(int dist[], int prev[], int src, int dest) {\n        System.out.println(\"Shortest distance from vertex \" + src + \" to vertex \" + dest + \" is \" + dist[dest]);\n        System.out.print(\"Path: \");\n        printPath(prev, dest);\n        System.out.println();\n    }\n\n    void printPath(int prev[], int j) {\n        if (prev[j] == -1) {\n            System.out.print(j);\n            return;\n        }\n        printPath(prev, prev[j]);\n        System.out.print(\" -> \" + j);\n    }\n\n    void dijkstra(int src, int dest) {\n        int dist[] = new int[V];\n        boolean sptSet[] = new boolean[V];\n        int prev[] = new int[V];\n\n        for (int i = 0; i < V; i++) {\n            dist[i] = Integer.MAX_VALUE;\n            sptSet[i] = false;\n            prev[i] = -1; // Initialize predecessors\n        }\n\n        dist[src] = 0;\n\n        for (int count = 0; count < V - 1; count++) {\n            int u = minDistance(dist, sptSet);\n            sptSet[u] = true;\n\n            for (int v = 0; v < V; v++) {\n                if (!sptSet[v] && graph[u][v] != 0 && dist[u] != Integer.MAX_VALUE\n                        && dist[u] + graph[u][v] < dist[v]) {\n                    dist[v] = dist[u] + graph[u][v];\n                    prev[v] = u; // Update predecessor\n                }\n            }\n        }\n\n        printSolution(dist, prev, src, dest);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        ShortestPath sp = new ShortestPath();\n\n        while (true) {\n            System.out.println(\"Menu:\");\n            System.out.println(\"1. Enter graph (adjacency matrix)\");\n            System.out.println(\"2. Find shortest path using Dijkstra's algorithm\");\n            System.out.println(\"3. Exit\");\n            System.out.print(\"Choose an option: \");\n            int choice = scanner.nextInt();\n\n            switch (choice) {\n                case 1:\n                    System.out.print(\"Enter the number of vertices: \");\n                    sp.V = scanner.nextInt(); // Set the number of vertices\n                    sp.graph = new int[sp.V][sp.V]; // Initialize the graph\n\n                    System.out.println(\"Enter the adjacency matrix (0 for no edge):\");\n                    for (int i = 0; i < sp.V; i++) {\n                        for (int j = 0; j < sp.V; j++) {\n                            sp.graph[i][j] = scanner.nextInt();\n                        }\n                    }\n                    break;\n\n                case 2:\n                    System.out.print(\"Enter the source vertex (0 to \" + (sp.V - 1) + \"): \");\n                    int src = scanner.nextInt();\n                    System.out.print(\"Enter the destination vertex (0 to \" + (sp.V - 1) + \"): \");\n                    int dest = scanner.nextInt();\n                    sp.dijkstra(src, dest);\n                    break;\n\n                case 3:\n                    System.out.println(\"Exiting...\");\n                    scanner.close();\n                    return;\n\n                default:\n                    System.out.println(\"Invalid option. Please try again.\");\n            }\n        }\n    }\n}""",
    "c2": """public class CRC {\n   // Method to compute CRC remainder\n   public static String computeCRC(String dataword, String divisor, int redundantBits) {\n       // Append zeros to dataword\n       String paddedDataword = appendZeros(dataword, redundantBits);\n       // Perform CRC calculation\n       String remainder = performDivision(paddedDataword, divisor);\n       return remainder; // Remainder after division\n   }\n\n   // Method to manually append zeros to the dataword\n   private static String appendZeros(String dataword, int numberOfZeros) {\n       StringBuilder sb = new StringBuilder(dataword);\n       for (int i = 0; i < numberOfZeros; i++) {\n           sb.append('0');\n       }\n       return sb.toString();\n   }\n\n   // Method to perform binary division using XOR operations\n   private static String performDivision(String data, String divisor) {\n       int dataLength = data.length();\n       int divisorLength = divisor.length();\n       StringBuilder dividend = new StringBuilder(data);\n\n       // Perform the division\n       for (int i = 0; i <= dataLength - divisorLength; i++) {\n           if (dividend.charAt(i) == '1') { // Only if the bit is 1\n               for (int j = 0; j < divisorLength; j++) {\n                   // XOR operation\n                   char newChar = (dividend.charAt(i + j) == divisor.charAt(j)) ? '0' : '1';\n                    dividend.setCharAt(i + j, newChar);\n                 }\n           }\n       }\n       // Extract the remainder\n       return dividend.substring(dataLength - divisorLength + 1);\n   }\n\n   public static void main(String[] args) {\n       // Predefined input values\n       String dataword = \"1011001\"; // Example dataword\n       String divisor = \"1101\";     // Example divisor\n       int redundantBits = divisor.length() - 1; // Number of redundant bits\n\n       // Sender Side\n       System.out.println(\"Sender Side:\");\n       // Compute CRC remainder\n       String paddedDataword = appendZeros(dataword, redundantBits);\n       String remainder = computeCRC(dataword, divisor, redundantBits);\n       // Compute codeword by appending the remainder to the dataword\n       String codeword = dataword + remainder;\n       // Output results\n       System.out.println(\"Dataword: \" + dataword);\n       System.out.println(\"Divisor: \" + divisor);\n       System.out.println(\"Number of Redundant Bits: \" + redundantBits);\n       System.out.println(\"Padded Dataword: \" + paddedDataword);\n       System.out.println(\"Remainder: \" + remainder);\n       System.out.println(\"Codeword: \" + codeword);\n\n       // Simulate receiver side\n       System.out.println(\"\\nReceiver Side:\");\n       // For demonstration, use the sent codeword as received data\n       verifyData(codeword, divisor);\n   }\n\n   // Method to verify received data and calculate remainder\n   public static void verifyData(String receivedCodeword, String divisor) {\n       String calculatedRemainder = performDivision(receivedCodeword, divisor);\n       System.out.println(\"Received Codeword: \" + receivedCodeword);\n       System.out.println(\"Calculated Remainder: \" + calculatedRemainder);\n\n       // Check if remainder is all zeros\n       if (calculatedRemainder.equals(\"0\".repeat(divisor.length() - 1))) {\n           System.out.println(\"Data is intact, checksum matches.\");\n       } else {\n           System.out.println(\"Data is corrupted, checksum does not match.\");\n       }\n   }\n}""",
    "c3": """import java.io.*;\nimport java.net.*;\n\npublic class MyServer {\n    public static void main(String[] args) {\n        try {\n            ServerSocket ss = new ServerSocket(6666);\n            System.out.println(\"Server is waiting for a client...\");\n\n            Socket s = ss.accept();\n            System.out.println(\"Client connected.\");\n\n            DataInputStream dis = new DataInputStream(s.getInputStream());\n            String str = dis.readUTF();\n            System.out.println(\"Message from client: \" + str);\n\n            dis.close();\n            s.close();\n            ss.close();\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e);\n        }\n    }\n}\n\nimport java.io.*;\nimport java.net.*;\n\npublic class MyClient {\n    public static void main(String[] args) {\n        try {\n            Socket s = new Socket(\"localhost\", 6666);\n            DataOutputStream dos = new DataOutputStream(s.getOutputStream());\n\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            System.out.print(\"Enter message: \");\n            String msg = br.readLine();\n            dos.writeUTF(msg);\n            dos.flush();\n\n            dos.close();\n            s.close();\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e);\n        }\n    }\n}""",
    "c4": """def crc_calculate(dataword, divisor):\n    # Append zeros to dataword\n    padded_dataword = dataword + '0' * (len(divisor) - 1)\n    # Perform division\n    remainder = perform_division(padded_dataword, divisor)\n    return remainder  # Return the CRC remainder\n\n\ndef perform_division(dividend, divisor):\n    # Perform binary division\n    divisor_length = len(divisor)\n    for i in range(len(dividend) - divisor_length + 1):\n        if dividend[i] == '1':  # Only when the leading bit is 1\n            dividend = dividend[:i] + xor_strings(dividend[i:i + divisor_length], divisor) + dividend[i + divisor_length:]\n    return dividend[-(divisor_length - 1):]  # Return the remainder\n\n\ndef xor_strings(a, b):\n    # Perform bitwise XOR operation on two binary strings\n    return ''.join('1' if x != y else '0' for x, y in zip(a, b))\n\n\ndef main():\n    dataword = '1101011011'  # Example dataword\n    divisor = '1101'  # Example divisor\n    crc = crc_calculate(dataword, divisor)\n    print(f'Dataword: {dataword}')\n    print(f'Divisor: {divisor}')\n    print(f'CRC: {crc}')\n\nif __name__ == '__main__':\n    main()""",
    "c5": """def calculate_checksum(data):\n    # Calculate one's complement checksum\n    total = 0\n    for i in range(0, len(data), 2):\n        # Take two bytes at a time\n        if i + 1 < len(data):\n            total += (data[i] << 8) + data[i + 1]\n        else:\n            total += (data[i] << 8)  # Last byte\n        # Wrap around if total is greater than 0xFFFF\n        total = (total & 0xFFFF) + (total >> 16)\n    # Return one's complement\n    return ~total & 0xFFFF\n\n\ndef sender_side(data):\n    # Sender side logic for calculating checksum\n    print(f'Original Data: {data}')\n    checksum = calculate_checksum(data)\n    print(f'Calculated Checksum: {checksum}')\n    return checksum\n\n# Example usage\nif __name__ == '__main__':\n    data = [0x1234, 0x5678, 0x9ABC, 0xDEF0]  # Example data\n    sender_side(data)"""
}


@app.route('/code/<code_id>', methods=['GET'])
def get_code(code_id):
    """Get code snippet by ID."""
    code = data.get(code_id)
    if code:
        return jsonify({"code": code}), 200
    else:
        return jsonify({"error": "Code snippet not found"}), 404

if __name__ == '__main__':
    app.run(debug=True)  # You can change the port if needed
